// internal/generator/registry_generator.go
package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// RegistryTemplateData данные для шаблона регистрации
type RegistryTemplateData struct {
	PackageName string
	Entities    []EntityInfo
	Imports     map[string]string
}

// EntityInfo информация о сущности для генерации
type EntityInfo struct {
	StructName string
	TableName  string
	Package    string
	ImportPath string
}

// GenerateRegistry генерирует файл с регистрацией сущностей
func GenerateRegistry(outputPath string, entities []EntityInfo) error {
	tmpl := `// Code generated by migrateme; DO NOT EDIT.
package {{.PackageName}}

import (
	"github.com/amr0ny/migrateme/internal/config"
	"github.com/amr0ny/migrateme/internal/infrastructure/postgres/schema"
	{{range $alias, $path := .Imports}}
	{{$alias}} "{{$path}}"{{end}}
)

func init() {
	cfg := config.GetConfig()
	{{range .Entities}}
	// Register {{.StructName}}
	cfg.Registry["{{.TableName}}"] = func(table string) schema.TableSchema {
		return schema.BuildSchema[{{if ne .Package "main"}}{{.Package}}.{{end}}{{.StructName}}](table)
	}{{end}}
}
`

	t, err := template.New("registry").Parse(tmpl)
	if err != nil {
		return fmt.Errorf("parse template: %w", err)
	}

	// Собираем импорты (исключаем main package и текущий package)
	imports := make(map[string]string)
	for _, entity := range entities {
		if entity.ImportPath != "" && entity.Package != "main" {
			// Создаем уникальный alias для каждого import path
			alias := generateImportAlias(entity.ImportPath, imports)
			imports[alias] = entity.ImportPath
		}
	}

	// Определяем package name из output path
	pkgName := filepath.Base(filepath.Dir(outputPath))
	if pkgName == "." || pkgName == "/" {
		pkgName = "migrator"
	}

	data := RegistryTemplateData{
		PackageName: pkgName,
		Entities:    entities,
		Imports:     imports,
	}

	var buf strings.Builder
	if err := t.Execute(&buf, data); err != nil {
		return fmt.Errorf("execute template: %w", err)
	}

	// Создаем директорию если нужно
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("create directory: %w", err)
	}

	if err := os.WriteFile(outputPath, []byte(buf.String()), 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}

	return nil
}

// generateImportAlias создает уникальный alias для import
func generateImportAlias(importPath string, existingImports map[string]string) string {
	base := filepath.Base(importPath)

	// Проверяем, не занят ли уже этот alias
	if _, exists := existingImports[base]; !exists {
		return base
	}

	// Если занят, добавляем суффикс
	for i := 1; ; i++ {
		alias := fmt.Sprintf("%s%d", base, i)
		if _, exists := existingImports[alias]; !exists {
			return alias
		}
	}
}

// DiscoverEntitiesForGeneration обнаруживает сущности для генерации
func DiscoverEntitiesForGeneration(paths []string) ([]EntityInfo, error) {
	var entities []EntityInfo

	for _, path := range paths {
		found, err := discoverInPath(path)
		if err != nil {
			return nil, fmt.Errorf("discover in %s: %w", path, err)
		}
		entities = append(entities, found...)
	}

	return entities, nil
}

// discoverInPath обнаруживает сущности в пути
func discoverInPath(path string) ([]EntityInfo, error) {
	var entities []EntityInfo

	info, err := os.Stat(path)
	if err != nil {
		return nil, err
	}

	if info.IsDir() {
		files, err := os.ReadDir(path)
		if err != nil {
			return nil, err
		}
		for _, file := range files {
			if strings.HasSuffix(file.Name(), ".go") && !strings.HasSuffix(file.Name(), "_test.go") {
				filePath := filepath.Join(path, file.Name())
				fileEntities, err := parseFile(filePath)
				if err != nil {
					return nil, fmt.Errorf("parse %s: %w", filePath, err)
				}
				entities = append(entities, fileEntities...)
			}
		}
	} else {
		fileEntities, err := parseFile(path)
		if err != nil {
			return nil, err
		}
		entities = append(entities, fileEntities...)
	}

	return entities, nil
}

// parseFile парсит файл и находит мигрируемые сущности
func parseFile(filePath string) ([]EntityInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var entities []EntityInfo

	// Получаем package и import path
	pkgName := node.Name.Name
	importPath := getImportPath(filePath)

	// Собираем все методы для проверки интерфейса
	methods := collectMethods(node)

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.GenDecl:
			if x.Tok == token.TYPE {
				for _, spec := range x.Specs {
					ts := spec.(*ast.TypeSpec)
					if st, ok := ts.Type.(*ast.StructType); ok {
						// Проверяем, является ли структура мигрируемой
						if isMigratableStruct(ts.Name.Name, st, node, methods) {
							tableName := extractTableName(ts, st, x.Doc)
							entities = append(entities, EntityInfo{
								StructName: ts.Name.Name,
								TableName:  tableName,
								Package:    pkgName,
								ImportPath: importPath,
							})
						}
					}
				}
			}
		}
		return true
	})

	return entities, nil
}

// collectMethods собирает все методы в файле
func collectMethods(file *ast.File) map[string]bool {
	methods := make(map[string]bool)

	for _, decl := range file.Decls {
		if fn, ok := decl.(*ast.FuncDecl); ok && fn.Recv != nil {
			methods[fn.Name.Name] = true
		}
	}

	return methods
}

// isMigratableStruct проверяет, является ли структура мигрируемой
func isMigratableStruct(structName string, st *ast.StructType, file *ast.File, methods map[string]bool) bool {
	// 1. Проверяем встраивание BaseMigratable
	if hasBaseMigratableEmbedding(st, file) {
		return true
	}

	// 2. Проверяем наличие метода TableName()
	if methods["TableName"] {
		// Проверяем, что TableName принадлежит этой структуре
		for _, decl := range file.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && fn.Name.Name == "TableName" {
				if fn.Recv != nil && len(fn.Recv.List) > 0 {
					if recvType, ok := fn.Recv.List[0].Type.(*ast.StarExpr); ok {
						if recvIdent, ok := recvType.X.(*ast.Ident); ok && recvIdent.Name == structName {
							return true
						}
					}
				}
			}
		}
	}

	// 3. Проверяем наличие db тегов
	return hasDBTags(st)
}

// hasBaseMigratableEmbedding проверяет встраивание BaseMigratable
func hasBaseMigratableEmbedding(st *ast.StructType, file *ast.File) bool {
	imports := getImportsMap(file)

	for _, field := range st.Fields.List {
		if len(field.Names) == 0 { // Анонимное поле (встраивание)
			switch t := field.Type.(type) {
			case *ast.SelectorExpr:
				if x, ok := t.X.(*ast.Ident); ok {
					if importPath, exists := imports[x.Name]; exists {
						if (x.Name == "domain" && t.Sel.Name == "BaseMigratable") ||
							(strings.HasSuffix(importPath, "/domain") && t.Sel.Name == "BaseMigratable") {
							return true
						}
					}
				}
			case *ast.Ident:
				if t.Name == "BaseMigratable" {
					return true
				}
			}
		}
	}
	return false
}

// hasDBTags проверяет наличие db тегов
func hasDBTags(st *ast.StructType) bool {
	for _, field := range st.Fields.List {
		if field.Tag != nil {
			tag := field.Tag.Value
			if strings.Contains(tag, `db:`) {
				return true
			}
		}
	}
	return false
}

// extractTableName извлекает имя таблицы
func extractTableName(ts *ast.TypeSpec, st *ast.StructType, doc *ast.CommentGroup) string {
	// 1. Из тега структуры
	if st.Fields.List != nil {
		for _, field := range st.Fields.List {
			if field.Tag != nil {
				tagValue := strings.Trim(field.Tag.Value, "`")
				if tableName := extractTableNameFromTag(tagValue); tableName != "" {
					return tableName
				}
			}
		}
	}

	// 2. Из комментария
	if doc != nil {
		for _, comment := range doc.List {
			text := strings.TrimSpace(comment.Text)
			if strings.Contains(text, "table=") {
				// Обрабатываем разные форматы комментариев
				text = strings.TrimPrefix(text, "//")
				parts := strings.Split(text, "table=")
				if len(parts) == 2 {
					return strings.TrimSpace(parts[1])
				}
			}
		}
	}

	// 3. По умолчанию - snake_case от имени структуры
	return toSnakeCase(ts.Name.Name)
}

// extractTableNameFromTag извлекает имя таблицы из тега
func extractTableNameFromTag(tag string) string {
	for _, part := range strings.Split(tag, " ") {
		if strings.HasPrefix(part, "table:") {
			tableTag := strings.TrimPrefix(part, "table:")
			return strings.Trim(tableTag, `"`)
		}
	}
	return ""
}

// getImportsMap возвращает map импортов
func getImportsMap(file *ast.File) map[string]string {
	imports := make(map[string]string)
	for _, imp := range file.Imports {
		path := strings.Trim(imp.Path.Value, `"`)
		var alias string
		if imp.Name != nil {
			alias = imp.Name.Name
		} else {
			alias = filepath.Base(path)
		}
		imports[alias] = path
	}
	return imports
}

// getImportPath определяет import path файла
func getImportPath(filePath string) string {
	absPath, err := filepath.Abs(filePath)
	if err != nil {
		return ""
	}

	// Ищем go.mod в родительских директориях
	dir := filepath.Dir(absPath)
	for dir != "" && dir != "/" {
		goModPath := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(goModPath); err == nil {
			// Читаем module name из go.mod
			content, err := os.ReadFile(goModPath)
			if err != nil {
				return ""
			}

			lines := strings.Split(string(content), "\n")
			for _, line := range lines {
				if strings.HasPrefix(line, "module ") {
					module := strings.TrimSpace(strings.TrimPrefix(line, "module "))
					relPath, err := filepath.Rel(dir, filepath.Dir(absPath))
					if err != nil {
						return ""
					}
					if relPath == "." {
						return module
					}
					return filepath.Join(module, relPath)
				}
			}
		}
		parent := filepath.Dir(dir)
		if parent == dir { // Достигли корня
			break
		}
		dir = parent
	}

	return ""
}

// toSnakeCase преобразует CamelCase в snake_case
func toSnakeCase(s string) string {
	var result []rune
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}
