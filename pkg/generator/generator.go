package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// ----------------------------------------
// Data types
// ----------------------------------------

type RegistryTemplateData struct {
	PackageName string
	Entities    []EntityInfo
	Imports     map[string]string
}

type EntityInfo struct {
	StructName string
	TableName  string
	Package    string
	ImportPath string
}

// ----------------------------------------
// Public API
// ----------------------------------------

func GenerateRegistry(outputPath string, entities []EntityInfo) error {
	tmpl := `// Code generated by migrateme; DO NOT EDIT.
package {{.PackageName}}

import (
	"github.com/amr0ny/migrateme/pkg/config"
	"github.com/amr0ny/migrateme/pkg/schema"
	"github.com/amr0ny/migrateme/pkg/migrate"
	{{range $alias, $path := .Imports}}
	{{$alias}} "{{$path}}"{{end}}
)

func init() {
	cfg := config.GetConfig()
	{{range .Entities}}
	// Register {{.StructName}}
	cfg.Registry["{{.TableName}}"] = func(table string) migrate.TableSchema {
		return schema.BuildSchema(table, {{if ne .Package "main"}}{{.Package}}.{{end}}{{.StructName}}{})
	}{{end}}
}
`

	t, err := template.New("registry").Parse(tmpl)
	if err != nil {
		return fmt.Errorf("parse template: %w", err)
	}

	imports := make(map[string]string)
	for _, e := range entities {
		if e.ImportPath != "" && e.Package != "main" {
			alias := generateImportAlias(e.ImportPath, imports)
			imports[alias] = e.ImportPath
		}
	}

	pkgName := filepath.Base(filepath.Dir(outputPath))
	if pkgName == "." || pkgName == "/" {
		pkgName = "migrator"
	}

	data := RegistryTemplateData{
		PackageName: pkgName,
		Entities:    entities,
		Imports:     imports,
	}

	var buf strings.Builder
	if err := t.Execute(&buf, data); err != nil {
		return fmt.Errorf("execute template: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("mkdir: %w", err)
	}

	if err := os.WriteFile(outputPath, []byte(buf.String()), 0644); err != nil {
		return fmt.Errorf("write: %w", err)
	}

	return nil
}
func DiscoverEntitiesForGeneration(paths []string) ([]EntityInfo, error) {
	var all []EntityInfo

	for _, p := range paths {
		found, err := discoverInPath(p)
		if err != nil {
			return nil, fmt.Errorf("discover in %s: %w", p, err)
		}
		all = append(all, found...)
	}

	return all, nil
}

// ----------------------------------------
// Discovery
// ----------------------------------------

func discoverInPath(path string) ([]EntityInfo, error) {
	var entities []EntityInfo

	info, err := os.Stat(path)
	if err != nil {
		return nil, err
	}

	if info.IsDir() {
		files, err := os.ReadDir(path)
		if err != nil {
			return nil, err
		}
		for _, f := range files {
			if strings.HasSuffix(f.Name(), ".go") &&
				!strings.HasSuffix(f.Name(), "_test.go") {

				fp := filepath.Join(path, f.Name())
				parsed, err := parseFile(fp)
				if err != nil {
					return nil, fmt.Errorf("parse %s: %w", fp, err)
				}
				entities = append(entities, parsed...)
			}
		}
		return entities, nil
	}

	return parseFile(path)
}

func parseFile(filePath string) ([]EntityInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var entities []EntityInfo

	pkgName := node.Name.Name
	importPath := detectImportPath(filePath)

	ast.Inspect(node, func(n ast.Node) bool {
		decl, ok := n.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			return true
		}

		for _, spec := range decl.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// только структуры
			if _, ok := ts.Type.(*ast.StructType); !ok {
				continue
			}

			// ищем комментарий // table:"..."
			table := extractTableFromComment(decl.Doc)
			if table == "" {
				continue
			}

			entities = append(entities, EntityInfo{
				StructName: ts.Name.Name,
				TableName:  table,
				Package:    pkgName,
				ImportPath: importPath,
			})
		}

		return true
	})

	return entities, nil
}

// ----------------------------------------
// Helpers
// ----------------------------------------

func extractTableFromComment(doc *ast.CommentGroup) string {
	if doc == nil {
		return ""
	}

	for _, c := range doc.List {
		text := strings.TrimSpace(strings.TrimPrefix(c.Text, "//"))
		text = strings.TrimSpace(strings.TrimPrefix(text, "/*"))
		text = strings.TrimSpace(strings.TrimSuffix(text, "*/"))

		// table:"name"
		if strings.HasPrefix(text, "table:") {
			val := strings.TrimPrefix(text, "table:")
			val = strings.TrimSpace(val)
			val = strings.Trim(val, `"'`)
			return val
		}
	}

	return ""
}

func generateImportAlias(importPath string, existing map[string]string) string {
	base := filepath.Base(importPath)
	if _, exists := existing[base]; !exists {
		return base
	}
	for i := 1; ; i++ {
		a := fmt.Sprintf("%s%d", base, i)
		if _, exists := existing[a]; !exists {
			return a
		}
	}
}

func detectImportPath(filePath string) string {
	abs, err := filepath.Abs(filePath)
	if err != nil {
		return ""
	}

	dir := filepath.Dir(abs)

	for dir != "/" && dir != "." {
		modPath := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(modPath); err == nil {
			content, err := os.ReadFile(modPath)
			if err != nil {
				return ""
			}

			var module string
			lines := strings.Split(string(content), "\n")
			for _, l := range lines {
				if strings.HasPrefix(l, "module ") {
					module = strings.TrimSpace(strings.TrimPrefix(l, "module "))
				}
			}

			rel, err := filepath.Rel(dir, filepath.Dir(abs))
			if err != nil {
				return ""
			}
			if rel == "." {
				return module
			}
			return filepath.ToSlash(filepath.Join(module, rel))
		}

		dir = filepath.Dir(dir)
	}

	return ""
}
